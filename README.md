> **Note:** This README was auto-generated by an AI assistant and may contain inaccuracies. Please verify critical details.

## 5DOF+Gripper RRRRR Robot Arm Simulator

This project simulates (and can optionally drive) a five-degree-of-freedom RRRRR arm with a gripper end-effector. It provides:

- **Forward and inverse kinematics** tuned to the arm’s actual link lengths and servo limits.
- **Workspace safety**: optional restricted zone (no points below ground, inside the base, or with positive Y) and gripper-horizontal mode.
- **Interactive Streamlit UI** with a 3D plotly visualization, joint sliders, presets, IK targeting, and restricted-zone overlay.
- **Hardware bridge** that streams servo updates to a real controller board sequentially from J6→J1.
- **Command-line controller** (`arm_control.py`) for scripted IK moves, linear/circular paths, and direct servo control.

The existing `RobotArm.md` file documents joint roles, link lengths, and base geometry.

---

### Requirements

- Python ≥ 3.13
- Dependencies listed in `pyproject.toml` (install via `uv pip install -r pyproject.toml` or `pip install -e .`)
- Optional hardware:
  - `ros_robot_controller_sdk` (provided in this repo as `ros_robot_controller_sdk.py`)
  - A compatible controller board connected to the host

---

### Quick Start

```bash
# Install dependencies
uv pip install -r pyproject.toml

# (Optional) launch the Streamlit UI
streamlit run streamlit_arm.py

# Or use the CLI controller
python arm_control.py
```

---

### Streamlit UI (`streamlit_arm.py`)

- Sliders for J1–J6 (0–1000) with live forward-kinematics display.
- IK target inputs (`x`, `y`, `z`) that choose the smoothest solution.
- Toggles for restricted zone and horizontal gripper modes.
- Visual overlays for the base and forbidden zone plus a gripper plane visualization.
- Quick preset buttons and gripper telemetry (state + width).

---

### CLI Controller (`arm_control.py`)

Start with `python arm_control.py`. Commands include:

| Command | Description |
| --- | --- |
| `target x y z` | IK move to absolute pose (mm). |
| `line x1 y1 z1 x2 y2 z2 [steps]` | Straight-line interpolation (default 20 steps). |
| `circle x y z diameter [steps]` | Horizontal circular path (requires horizontal mode OFF). |
| `set Jn value` | Direct servo command for joint `Jn` or `n`. |
| `open` / `close` | Control the gripper (J1). Only J1 is touched. |
| `reset` | Return all joints to neutral (500). |
| `restrict on/off` | Toggle workspace guard. |
| `horizontal on/off` | Toggle gripper-horizontal constraint. |
| `hardware on [speed]` / `hardware off` | Attach/detach the board (speed ∈ 0–1). |
| `joints`, `fk`, `help`, `quit` | Introspection or exit. |

Under the hood the CLI keeps a single `RobotArm` instance alive for the whole session. Restricted-zone and horizontal-gripper modes start enabled, but you can flip them at any time via the `restrict` / `horizontal` commands; the new state takes effect immediately for every subsequent move. When you attach hardware the same object begins streaming servo updates (still in J6→J1 order) and all subsequent commands operate on the real arm. Because everything routes through `RobotArm`, the CLI gets the same IK scoring, motion primitives, and safety checks that the Streamlit UI uses.

---

### Hardware Control

`RobotArm.attach_hardware()` attempts to import `ros_robot_controller_sdk.Board`. When attached:

- Servo updates are streamed one joint at a time (J6→J1) via `_set_servo_position`.
- `attach_hardware(auto_initialize=True)` runs a default sequence (J6 first, J1 last). Pass `auto_initialize=False` to sync without moving.
- `detach_hardware()` stops hardware updates but keeps the simulated state.

Example:

```python
from arm import RobotArm

arm = RobotArm()
arm.attach_hardware(speed=0.3)   # auto-init servos
arm.inverse_kinematics(120, -50, 150, apply=True)
arm.detach_hardware()
```

---

### Testing & Development Notes

- The repo defaults to a restricted zone and horizontal-gripper mode enabled (you can toggle them in the UI/CLI/API).
- Inverse kinematics enumerates multiple wrist and elbow configurations and sorts by total servo travel, squared travel, and number of joints moved.
- Motion primitives (`move_end_effector_line`, `move_end_effector_circle`) execute via repeated IK solves; they abort if any waypoint is unreachable.
- The CLI and Streamlit app share the same `RobotArm` class, so new features added in `arm.py` immediately become available everywhere.

---

For more mechanical details (joint descriptions, link lengths, and base layout), see `RobotArm.md`. Contributions and extensions—new motion primitives, visualizations, or controller backends—are welcome. Happy hacking!
